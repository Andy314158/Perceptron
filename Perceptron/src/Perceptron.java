import java.io.*;
import java.util.*;

public class Perceptron {

	private List<Image> imageList = new ArrayList<Image>();

	public Perceptron(String fileName) {
		loadData(fileName);
		constructFeatures();
	}

	
	public void constructFeatures() {
		int NUM_FEATURES = 50;
		List<Feature> featureList = new ArrayList<Feature>();// list of features

		CoOrds[] v = new CoOrds[NUM_FEATURES];
		CoOrds[] x = new CoOrds[NUM_FEATURES];
		CoOrds[] y = new CoOrds[NUM_FEATURES];
		CoOrds[] z = new CoOrds[NUM_FEATURES];

		// returns a random CoOrd, eg CoOrd with col <=9 and row <=9
		for (int i = 0; i < NUM_FEATURES; i++) {
			v[i] = randomCoOrd(0, 9);
			x[i] = randomCoOrd(0, 9);
			y[i] = randomCoOrd(0, 9);
			z[i] = randomCoOrd(0, 9);
		}

		// from the list of random CoOrds above, construct a Feature and add it to the
		// feature list
		for (int i = 0; i < NUM_FEATURES; i++) {
			Map<CoOrds, Boolean> list = new HashMap<CoOrds, Boolean>();
			list.put(v[i], randomBoolean());
			list.put(x[i], randomBoolean());
			list.put(y[i], randomBoolean());
			list.put(z[i], randomBoolean());
			Feature f = new Feature(list);
			featureList.add(f);
		}

		// construct weights with value initialised as 1
		double[] weights = new double[50];
		
		for(int i= 0; i<49;i++) {
			weights[i]=randomNumber(-1,1);
		}
		weights[4] = 1;// this is the bias. always 1

		// loop through all instances (complete one epoch) until desired accuracy is
		// achieved. Predicted output y is equal to 0 if it thinks the image is an O and 1 if it 
		//predicts X. Output y is generated by threshold (sum>0) if sum is larger than 0 then y=1.
		//if prediction is X, eg 1 but the classification number on the image is 0 then the weights are adjusted
		//and vise versa.
		
		double accuracy = 0;
		for (int epoch = 0; (epoch < 10 && accuracy <= 100); epoch++) {
			
            int theta=0;
			double correct = 0;
			double wrong = 0;
            
			for (Image image : imageList) {// iterate through each image
				for (Feature f : featureList) {
					f.calculateFeatureValue(image);// update feature values for each feature
				}

					int sum = 0;
					for (int i = 0; i < weights.length-1; i++) {
						sum += (weights[i] * featureList.get(i).featureValue);
					}
					sum+= weights[4]*1;//add the bias
					int Y;
					if((sum+theta)>0)
						Y=1;
					else
						Y=0;
					// as per lecture slides!
					if (Y == 0) {
						if (image.getClassification() != 0) {// if prediction is not the actual outcome
							for(int i=0;i<weights.length;i++) {
								weights[i]=adjustWeightOne(weights[i], featureList.get(i).featureValue);
							}
							weights[4] = weights[4]++;//increment bias
							wrong++;
						} else
							correct++;

					} else if (Y == 1) {
						if (image.getClassification() != 1) {// if prediction is not the actual outcome
							for(int i=0;i<weights.length;i++) {
								weights[i]=adjustWeightTwo(weights[i], featureList.get(i).featureValue);
							}
							weights[4] = weights[4]--;//decrement bias
							wrong++;
						} else
							correct++;
					}
					accuracy = (int)(100*correct / (correct + wrong));
					System.out.println(accuracy);
				}
		}
	}

	/**
	 * As described in hand out... if 
	 * @param d
	 * @param featureValue
	 * @return
	 */
	private double adjustWeightTwo(double d, int featureValue) {
			return (d - featureValue);
	}

	private double adjustWeightOne(double d, int featureValue) {
			return (d + featureValue);
	}

	private boolean randomBoolean() {
		Double rand = Math.random();
		if (rand > 0.5)
			return true;
		else
			return false;
	}

	private CoOrds randomCoOrd(int min, int max) {
		CoOrds p = new CoOrds((int) (min + Math.random() * (max)), (int) (min + Math.random() * max));
		return p;
	}

	private static double randomNumber(int min, int max) {
		return min + Math.random() * max;
	}

	/**
	 * Simply load data and store images into an image list with corresponding
	 * category
	 * 
	 * @param fname
	 */
	public void loadData(String fname) {

		File file = new File(fname);
		try {
			Scanner scan = new Scanner(file);
			while (scan.hasNextLine()) {
				scan.nextLine();
				String type = scan.nextLine();
				scan.nextInt();
				scan.nextInt();
				scan.nextLine();
				int[] numbers = new int[100];
				int i = 0;
				String line = scan.nextLine();
				line = line + scan.nextLine();
				for (int a = 0; a < 99; a++) {
					numbers[a] = Integer.decode(line.substring(a, a + 1));
				}
				numbers[99] = Integer.decode(line.substring(99));

				int[][] array = new int[10][10];
				for (int r = 0; r < 10; r++) {
					for (int c = 0; c < 10; c++) {
						array[r][c] = numbers[r + c];
					}
				}
				int t;
				if (type.equals("#X"))
					t = 0;
				else
					t = 1;

				Image img = new Image(array, t);
				imageList.add(img);
			}
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}

	}

	public static void main(String args[]) {
		Perceptron p = new Perceptron(args[0]);
	}
}
